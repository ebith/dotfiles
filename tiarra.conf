# -*- tiarra-conf -*-
# -----------------------------------------------------------------------------
# $Id: sample.conf.in 3010 2007-12-10 13:36:55Z topia $
# -----------------------------------------------------------------------------
# tiarra.conf サンプル
#
# tiarraは起動時に全ての設定をこのファイルから取得します。
# このファイルの文字コードは任意ですが、改行コードはLFもしくはCRLFでなければなりません。
#
# 半角の#で始まる行はコメントとして無視されます。
# 行の途中に#を置いた場合はコメントにはなりません。
#
# 設定行は「設定名 : 値」の形式で指定されます。
# 行の先頭及び末尾、コロンの前後の空白は無視されます。
#
# 特に指定が無い場合、同じ設定を二度以上繰り返した時は最初に定義された設定が有効になります。
#
# ブロックごと省略した場合は、そのブロックの全ての値が省略されたものとみなします。
# ただし省略不可能な設定もありますので御注意下さい。
#
# 「@include foo.conf」という行があると、foo.confがその場所に
#  挿入されたかのように処理します。
#
# {}記号の位置には、それなりの自由度があります。
# 次の例は全て有効です。
# block {
#   foo: bar
# }
#
# block {}
#
# block
# {}
#
# 次の例は全て無効です。
# block {foo: bar}
#
# block
# {foo: bar}
# 
# block {
# foo: bar}
# 
# block
# {foo: bar
# }
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# generalブロック
#
# tiarra.conf自身の文字コードやユーザー情報などを指定するブロックです。
# -----------------------------------------------------------------------------
general {
  # tiarra.conf自身の文字コード
  # コード名はjis,sjis,euc,utf8,utf16,utf32等。(この値はUnicode::Japaneseにそのまま渡されます)
  # autoが指定された、または省略された場合は自動判別します。
  conf-encoding: euc

  # ユーザー情報
  # 省略不能です。
  nick: ebith
  user: ebith
  name: ebith hydrangea

  # どのようなユーザーモードでログインするか。+iwや+iのように指定する。
  # 省略された場合はユーザーモードを特に設定しない。
  #user-mode: +i

  # Tiarraへの接続を許可するホスト名を表わすマスク。
  # 制限をしないのであれば"*"を指定するか省略する。
  client-allowed: *

  # Tiarraが開くポート。ここに指定したポートへクライアントに接続させる。
  # 省略されたらポートを開かない。
  tiarra-port: 6667

  # Tiarraがポートtiarra-portを開く際、IPv6とIPv4のどちらでリスニングを行なうか。
  # 'v4'または'v6'で指定します。デフォルトは'v4'です。
  # IPv6を使うためにはSocket6.pmが利用可能である必要があります。
  #tiarra-ip-version: v4

  # Tiarraがポートtiarra-portを開く際のローカルアドレス。
  # 意味が分からなければ省略して下さい。
  # デフォルトは、IPv4のはINADDR_ANY、IPv6のはin6addr_anyになります。
  #tiarra-ipv4-bind-addr: 0.0.0.0
  #tiarra-ipv6-bind-addr: ::0

  # Tiarraにクライアントが接続する際に要求するパスワードをcryptした文字列。
  # 空の文字列が指定されたり省略された場合はパスワードを要求しない。
  # crypt は ./tiarra --make-password で行えます。
  tiarra-password: JT7MK21vDE9/2

  # 外部プログラムからtiarraをコントロールする為のUNIXドメインソケットの名前。
  # 例えば"foo"を指定した場合、ソケット/tmp/tiarra-control/fooが作られる。
  # 省略された場合はこの機能を無効とする。
  # また、非UNIX環境ではそもそもUNIXドメインソケットが利用可能でないため、
  # そのような場合にもこの機能は無効となる。
  #control-socket-name: test

  # IRCサーバーから送られる文字のコードと、IRCサーバーへ送る文字のコード
  # どちらも省略された場合はjis。
  server-in-encoding: jis
  server-out-encoding: jis

  # クライアントから受け取る文字のコードと、クライアントへ伝える文字のコード
  # どちらも省略された場合はjis。
  client-in-encoding: utf8
  client-out-encoding: utf8

  # Tiarraは標準出力に様々なメッセージを出力するが、その文字コードを指定する。省略時にはeucとなる。
  # ただしtiarra.confのパースが完了するまでは文字コードの変換は行なわれない(つまりこの設定が有効にならない)ことに注意して下さい。
  stdout-encoding: utf8

  # Tiarraはエラーメッセージを標準出力に出力するが、その時に接続しているクライアントがあればクライアントにもNOTICEで送る事が出来る。
  # この値を1にすると、その機能が有効になる。省略するか0を指定するとこの機能は無効になる。
  notice-error-messages: 1

  # Tiarraでチャンネルとユーザーのマスクを指定するときの形式。
  # plum形式とTiarra形式が選択できます。
  #-----------------
  # plum形式: (channelには+や-は使えない。channelは省略すると*とみなす。)
  #   + syntax: user[ channel[ channel[ ...]]]
  #
  #  mask: +*!*@*.example.com #{example}@ircnet +{example3}@ircnet
  #  mask: -*!*@*.example.com #{example2}@2ch,+{example4}@2ch
  #  mask: -*!*@*
  #-----------------
  # Tiarra形式: (channelにも+や-を使える。)
  #   + syntax: channel user
  #
  #  mask: #{example}@ircnet,-#{example2}@2ch    +*!*@*.example.com
  #  mask: ++{example3}@ircnet,-+{example4}@2ch  +*!*@*.example.com # +で始まるチャンネル。
  #  mask: *                                     -*!*@*
  #-----------------
  # となります。 この二つはまったく同じマスクを表しています。

  # この値をplumにすると、plum形式、省略するかtiarraを指定すると、Tiarra形式になります。
  chanmask-mode: tiarra

  # サーバーに接続する際、ローカル側のどのアドレスにバインドするか。
  # 意味が分からなければ省略して下さい。
  # デフォルトは、IPv4のはINADDR_ANY、IPv6のはin6addr_anyになります。
  #ipv4-bind-addr: 0.0.0.0
  #ipv6-bind-addr: ::0

  # tiarra が、 001 や 002 や、 recent log を送信するときなどに使う prefix
  # を指定します。 hostname や fqdn っぽいものを指定すると良いかもしれません。
  # デフォルトは tiarra です。普通変える必要はありません。
  #sysmsg-prefix: tiarra

  sysmsg-prefix-use-masks {
    # sysmsg-prefix を使用する場所を指定する。

    # システムメッセージ(NumericReply など)。デフォルトは * です。
    # ふつうこれを変更する必要はありません。
    system: *

    # 個人宛メッセージ(Notice,Privmsg の中で)。デフォルトはなし。
    #priv: 

    # チャンネル宛メッセージ(Notice,Privmsg の中で)。デフォルトは * です。
    # Ziciz などのクライアントを接続する場合は、
    # -*::log を指定しておくといいかもしれません。
    channel: *
  }

  # Tiarra が nick 変更時の衝突等を処理するモードを指定します。
  # 0: Tiarra が接続時と同様に自動処理します。
  # 1: クライアントにそのまま投げます。
  #    複数のクライアントが nick 重複を処理する場合は非常に危険です。
  #    (設定不足の IRC クライアントが複数つながっている場合も含みます)
  # 2: 対応するエラーメッセージ付きの NOTICE に変換して、
  #    クライアントに投げます。
  # multi-server-mode 時のデフォルトは 0 、 single-server-mode 時のデフォルトは 1 です。
  nick-fix-mode: 0

  messages {
    # Tiarra が使用する、いくつかのメッセージを指定する。

    quit {
      # ネットワーク設定が変更され、再接続する場合の切断メッセージ
      netconf-changed-reconnect: Server Configuration changed; reconnect

      # ネットワーク設定が変更され、切断する場合の切断メッセージ
      netconf-changed-disconnect: Server Configuration changed; disconnect
    }
  }
}

# -----------------------------------------------------------------------------
# networksブロック
#
# Tiarraから接続するIRCネットワークの名称です。
# 一つも定義しなかった場合やこのブロックを省略した場合は、
# "main"というネットワークが一つだけ指定されたものと見做します。
# -----------------------------------------------------------------------------
networks {
  # 複数のサーバーへの接続を可能にするかどうか。1(オン)と0(オフ)で指定。
  # これを1にすると、次のnameを複数個定義する事が可能になり、
  # 複数のサーバーに同時に接続出来るようになります。
  # その一方、これを1にしている時は、チャンネル名にネットワーク名が付加される等、
  # IRCの大部分のメッセージがTiarraによる改変を受けます。
  # これを0にしている間は、次のnameを複数個定義する事は出来なくなります。
  # マルチサーバーモードの設定を起動中に変えると、クライアントから見たチャンネル名が
  # 変更になる為、全クライアントが一時的に全てのチャンネルからpartしたように見え、
  # その直後にjoinし直したように見えます。
  # デフォルトでは1です。
  multi-server-mode: 1

  # 接続するIRCネットワークに名前を付けます。この名前は後で使用します。
  # 複数のネットワークに接続したい場合は多重定義して下さい。
  name: friend
  name: twitter

  # 通常Tiarraではチャンネル名を「#Tiarra@ircnet」のように表現します。
  # これはネットワークircnet内の#Tiarraというチャンネルを表わします。
  # @以降は省略可能ですが、省略された場合のデフォルトのネットワーク名をここで指定します。
  # 省略した場合は最も始めに定義されたnameがデフォルトになります。
  # (そしてnameが一つも無かった場合はmainがデフォルトになります)
  #default: ircnet

  # 上に述べた通り、デフォルトではTiarraはチャンネル名とネットワーク名を@で区切ります。
  # この区切り文字は任意の文字に変更する事が出来ます。省略された場合は@になります。
  #
  # System::PrivTranslator モジュールを利用している場合、 prefix の nick 部分にも
  # 利用されます。そのため、 ! や @ を含む文字列を利用するとクライアントが誤作動する
  # 場合がありますので注意してください。
  channel-network-separator: @

  # 接続先のサーバーから切断された時に、joinしていたそのサーバーのチャンネルをどうするか。
  # 1. "part-and-join"の場合は、切断されるとクライアントにはチャンネルからpartしたように見せ掛け、
  #    再接続に成功すると再びjoinしたように見せ掛ける。最も負荷が高い。(これはplumに似た動作である)
  # 2. "one-message"の場合は、切断されるとクライアントに宛ててTiarraがNOTICEでその旨を報告する。
  #    再接続に成功すると再びNOTICEで報告する。JOINやPARTはしないので、
  #    クライアントからはまだそのチャンネルに残っているかのように見える。
  # 3. "message-for-each"の場合は、切断されるとクライアントに宛ててTiarraが
  #    到達不能になった全てのチャンネルにNOTICEでその旨を報告する。
  #    再接続に成功すると再びNOTICEで報告する。JOINやPARTはしない。
  # デフォルトはpart-and-joinです。
  action-when-disconnected: message-for-each

  # NICKを変更する度に、変更したサーバーでの新しいNICKをNOTICEで常に通知するかどうか。
  # 1なら必ず通知し、0なら変更後のnickがローカルnick(クライアントが見る事の出来るnick)と違っている場合のみ通知する。
  # デフォルトは0です。
  always-notify-new-nick: 0

  fixed-channels {
    # Tiarra がクライアント接続時にチャンネル情報を送る順番を指定する。
    # マッチしなかったチャンネルについては最後にまとめて
    # (順番がごちゃごちゃになって)送られてきます。
    channel: #おいら屋ファクトリー@friend
    channel: #twitter@twitter
    channel: #silverthaw@friend
  }
}

# -----------------------------------------------------------------------------
# 各ネットワークの設定
#
# networksブロックで定義した全てのネットワークについて、
# そのアドレス、ポート、(必要なら)パスワードを定義します。
# -----------------------------------------------------------------------------
friend {
  # サーバーのホストとポート。省略不可。
  host: irc.friend-chat.jp
  port: 6663

  # general/userで設定したユーザ名を使わずに、各ネットワークで独自のユーザ名を使用する事も可能。
  # 省略されたら当然、general/userで設定したものが使われる。
  #user: hoge

  # general/nameで設定した本名(建前上)を使わずに、各ネットワークで独自の本名を使用可能。
  #name: hoge

  # このサーバーの要求するパスワード。省略可能。
  password: friendconn

  # general/setver-in/out-encodingで設定したエンコーディングを使わずに、
  # 各ネットワークで独自のエンコーディングを使用する事も可能。
  # 省略されたら当然、generalで設定したものが使われる。
  #in-encoding: jis
  #out-encoding: jis

  # general/(ipv4|ipv6)bind-addrで設定したローカルアドレスを使わずに、
  # 各ネットワークで独自のbind_addrを使用する事も可能。
  # 省略されたらgeneralで設定したものが使われる。
  #ipv4-bind-addr: 0.0.0.0
  #ipv6-bind-addr: ::0
}
twitter {
  host: 127.0.0.1
  port: 16668
  user: ebith
  name: ebith
  password: 1010054
  in-encoding: utf8
  out-encoding: utf8
}
# -----------------------------------------------------------------------------
# 必須の設定は以上です。以下はモジュール(プラグイン)の設定です。
# -----------------------------------------------------------------------------

# +または-で始まる行はモジュール設定行と見做されます。
# +で記述されたモジュールが使用され、-で記述されたモジュールは使用されません。
# +や-の後の空白は幾つあっても無視されます。

#   メッセージが各モジュールを通過する順番は、このconfファイルで記述された
# 順番の通りになります。ログを取るモジュールなどはconfでも後の方に
# 記述した方が良いということになります。

#   モジュール名はperlのそれと同じようにディレクトリ区切り文字を「::」としたパスで表現されます。
# 例えばモジュールChannel::Auto::Operの実体はファイルmodule/Channel/Auto/Oper.pm
# でなければならず、そのpackage宣言もChannel::Auto::Operでなければなりません。
#   Tiarraモジュールの名称は、perl標準モジュール群やmain/下の.pmファイルと重複しないように
# 気を付けて下さい。Tiarraはモジュールが本当にModuleのサブクラスかどうかをチェックするので
# 例えばIO::Socket::INETといったモジュールを置いても誤動作はしませんが、
# そのようなモジュールはロード時にエラーを出して使用中止になります。

# 一つのモジュールを複数回定義して、何度も同じモジュールをメッセージが通過するようには出来ません。

# 幾つかのモジュールはパラメータとしてチャンネル名を必要とします。
# ここで指定するチャンネル名は、ネットワーク名も含めた文字列でなければなりません。
# 「#チャンネル」では駄目で「#チャンネル@ネットワーク」などとする必要があります。

# マスクの書式:
# ['+' / '-'] ( <マスク文字列> / "re:" 正規表現 )
# これはカンマで幾つでも継ぐ事が出来ます。"\,"でカンマそのものを表します。
# 先頭が+なら、それに続く部分にマッチするものが選ばれ、-なら除外されます。省略されたら+と見做されます。
# マスク文字列とは"*"で0文字以上の任意の文字列を、"?"で1文字の任意の文字列を表す文字列です。
# 例:
# tiarra*  これはtiarraで始まる文字列を表す。
# +*!*tiarra@*.jp,-re:\d  これは*!*tiarra@*.jpにマッチして、かつ文字列中に数字を含まないものを表す。

# このファイルには重要と思われるいくつかのモジュールしかありません。
# そのほかのモジュールについては、 all.conf から設定をコピーしてきてください。

+ Auto::FetchTitle {
  # 発言に含まれるURLからタイトルを取得.

  # リクエストタイムアウトまでの時間(秒).
  timeout: 15

  # 有効にするチャンネルとオプションとURLの設定.
  # 書式: mask: <channel> [...] <url>
  #
  # mask: #test@ircnet &test http://*
  # mask: * http://*
  mask: *@friend http://*

  # &test と設定すると conf-test ブロックの中身が使われる.
  #conf-test {
  #  auth-test1 {
  #    url:  http://example.com/*
  #    url:  http://example.org/*
  #    user: test
  #    #pass: test
  #    pass: {BASE64}dGVzdAo=
  #  }
  #  filter-xx {
  #    url:  http://example.com/*/xx/*
  #    type: xx
  #  }
  #}

  # お返事の前や後ろにつける字句.
  reply-prefix: ""
  reply-suffix: ""

  # デバッグフラグ.
  #debug: 0
  #debug-mask: #debug-chan your_nick!~you@example.com
  #debug-dumpfile: fetchtitle.log

  # NOTE:
  #  利用するにはcodereposから
  #  module/Tools/HTTPClient.pm     rev.8220
  #  main/Tiarra/Socket/Buffered.pm rev.8219
  #  以降が必要です.
}

- Channel::Join::Connect {
  # サーバーに初めて接続した時、指定したチャンネルに入るモジュール。

  # 書式: <チャンネル1>[,<チャンネル2>,...] [<チャンネル1のキー>,...]
  #     コンマの直後のスペースは無視されます。
  #
  # 例:
  #   「#aaaaa@ircnet」に「aaaaa」というキーで入る。
  #channel: #aaaaa@ircnet aaaaa
  #
  #   「#aaaaa@ircnet」、「#bbbbb@ircnet:*.jp」、「#ccccc@ircnet」、「#ddddd@ircnet」の4つのチャンネルに入る。
  #channel: #aaaaa@ircnet,#bbbbb@ircnet:*.jp, #ccccc@ircnet
  #channel: #ddddd@ircnet
  #channel: #おいら屋ファクトリー@friend
  #channel: #silverthaw@friend
}

+ Channel::Join::Kicked {
  # 特定のチャンネルからkickされた時に、自動で入りなおす。

  # 対象となるチャンネル名のマスク
  channel: *
}

+ Channel::Mode::Get {
  # チャンネルにJOINした時、そのチャンネルのモードを取得します。

  # Channel::Mode::Set等が正しく動くためには
  # チャンネルのモードをTiarraが把握しておく必要があります。
  # 自動的にモードを取得するクライアントであれば必要ありませんが、
  # そうでなければこのモジュールを使うべきです。

  # 設定項目は無し。
}

+ Channel::Mode::Oper::Grant {
  # 特定のチャンネルに特定の人間がjoinした時に、自分がチャンネルオペレータ権限を持っていれば+oする。

  # splitからの復帰などで+o対象の人が一度に大量に入って来ても+oは少しずつ実行します。
  # Excess Floodにはならない筈ですが、本格的な防衛BOTに使える程の物ではありません。

  # 対象の人間がjoinしてから実際に+oするまで何秒待つか。
  # 省略されたら待ちません。
  # 5-10 のように指定されると、その値の中でランダムに待ちます。
  wait: 2-300

  # チャンネルと人間のマスクを定義。Auto::Operと同様。
  mask: * Clale!~clale@*.adsl.ppp.infoweb.ne.jp,Tiele!~Tiele@*.ap122.ftth.ucom.ne.jp,ixtlilton!~username@*.dynamic.ppp.asahi-net.or.jp,Clelia!~clelia@*.eo.eaccess.ne.jp,ipio!~UserID@*.rev.home.ne.jp,Poikichi!~UserID@*.osaknt01.ap.so-net.ne.jp,[haya]!~[haya]@*.dy.bbexcite.jp,Devil!~UserID@*.nara.ocn.ne.jp,Oyoto!~Oyoto@*.dy.iij4u.or.jp
}

+ Channel::Rejoin {
  # チャンネルオペレータ権限を無くしたとき、一人ならjoinし直す。

  # +チャンネルや+aされているチャンネル以外でチャンネルオペレータ権限を持たずに
  # 一人きりになった時、そのチャンネルの@を復活させるために自動的にjoinし直すモジュール。
  # トピック、モード、banリスト等のあらゆるチャンネル属性をも保存します。

  # +b,+I,+eリストの復旧を行なうかどうか。
  # あまりに長いリストを取得するとMax Send-Q Exceedで落とされるかも知れません。
  save-lists: 1
}

+ Client::Conservative {
  # サーバが送信するような IRC メッセージを作成するようにする

  # サーバが実際に送信しているようなメッセージにあわせるようにします。
  # 多くのクライアントの設計ミスを回避でき(ると思われ)ます。
}

+ Client::Cotton {
  # Cotton の行うおかしな動作のいくつかを無視する

  # 該当クライアントのオプション client-type に cotton や unknown と指定するか、
  # Client::GetVersion を利用してクライアントのバージョンを取得するように
  # してください。

  # part shield (rejoin 時に自動で行われる part の無視)を使用するか
  use-part-shield: 1
}

+ Client::GetVersion {
  # クライアントに CTCP Version を発行してバージョン情報を得る

  # オプションはいまのところありません。
  # (開発者向け情報: 取得した情報は remark の client-version に設定され、
  #                  Client::Guess から使用されます。)
}

+ Log::Channel {
  # チャンネルやprivのログを取るモジュール。

  # Log系のモジュールでは、以下のように日付や時刻の置換が行なわれる。
  # %% : %
  # %Y : 年(4桁)
  # %m : 月(2桁)
  # %d : 日(2桁)
  # %H : 時間(2桁)
  # %M : 分(2桁)
  # %S : 秒(2桁)

  # ログを保存するディレクトリ。Tiarraが起動した位置からの相対パス。~指定は使えない。
  directory: log

  # ログファイルの文字コード。省略されたらjis。
  charset: utf8

  # 各行のヘッダのフォーマット。省略されたら'%H:%M'。
  header: %H:%M

  # ファイル名のフォーマット。省略されたら'%Y.%m.%d.txt'
  filename: %Y.%m.%d.txt

  # ログファイルのモード(8進数)。省略されたら600
  mode: 600

  # ログディレクトリのモード(8進数)。省略されたら700
  dir-mode: 700

  # ログを取るコマンドを表すマスク。省略されたら記録出来るだけのコマンドを記録する。
  command: privmsg,join,part,kick,invite,mode,nick,quit,kill,topic,notice

  # PRIVMSGとNOTICEを記録する際に、自分の発言と他人の発言でフォーマットを変えるかどうか。1/0。デフォルトで1。
  distinguish-myself: 1

  # 各ログファイルを開きっぱなしにするかどうか。
  # このオプションは多くの場合、ディスクアクセスを抑えて効率良くログを保存しますが
  # ログを記録すべき全てのファイルを開いたままにするので、50や100のチャンネルを
  # 別々のファイルにログを取るような場合には使うべきではありません。
  # 万一 fd があふれた場合、クライアントから(またはサーバへ)接続できない・
  # 新たなモジュールをロードできない・ログが全然できないなどの症状が起こる可能性が
  # あります。limit の詳細については OS 等のドキュメントを参照してください。
  keep-file-open: 1

  # keep-file-open 時に各行ごとに flush するかどうか。
  # open/close の負荷は気になるが、ログは失いたくない人向け。
  # keep-file-open が有効でないなら無視され(1になり)ます。
  #always-flush: 0

  # keep-file-openを有効にした場合、発言の度にログファイルに追記するのではなく
  # 一定の分量が溜まってから書き込まれる。そのため、ファイルを開いても
  # 最近の発言はまだ書き込まれていない可能性がある。
  # syncを設定すると、即座にログをディスクに書き込むためのコマンドが追加される。
  # 省略された場合はコマンドを追加しない。
  sync: sync

  # 各チャンネルの設定。チャンネル名の部分はマスクである。
  # 個人宛てに送られたPRIVMSGやNOTICEはチャンネル名"priv"として検索される。
  # 記述された順序で検索されるので、全てのチャンネルにマッチする"*"などは最後に書かなければならない。
  # 指定されたディレクトリが存在しなかったら、Log::Channelはそれを勝手に作る。
  # フォーマットは次の通り。
  # channel: <ディレクトリ名> (<チャンネル名> / 'priv')
  # 例:
  # filename: %Y.%m.%d.txt
  # channel: IRCDanwasitu #IRC談話室@ircnet
  # channel: others *
  # この例では、#IRC談話室@ircnetのログはIRCDanwasitu/%Y.%m.%d.txtに、
  # それ以外(privも含む)のログはothers/%Y.%m.%d.txtに保存される。
channel:priv priv
channel:#(channel) *
channel:others *
}

+ Log::Recent {
  # クライアントを接続した時に、保存しておいた最近のメッセージを送る。

  # クライアントオプションの no-recent-logs が指定されていれば送信しません。

  # 各行のヘッダのフォーマット。省略されたら'%H:%M'。
  header: %H:%M

  # ログをチャンネル毎に何行まで保存するか。省略されたら10。
  line: 50

  # PRIVMSGとNOTICEを記録する際に、自分の発言と他人の発言でフォーマットを変えるかどうか。1/0。デフォルトで1。
  distinguish-myself: 1

  # どのメッセージを保存するか。省略されたら保存可能な全てのメッセージを保存する。
  command: privmsg,notice,topic,join,part,quit,kill
}

+ System::Error {
  # サーバーからのERRORメッセージをNOTICEに埋め込む

  # これをoffにするとクライアントにERRORメッセージがそのまま送られます。
  # クライアントとの間ではERRORメッセージは主に切断警告に使われており、
  # そのまま流してしまうとクライアントが混乱する可能性があります。
  #   設定項目はありません。

  # このモジュールを回避してERRORメッセージをクライアントに送りたい場合は、
  # remarkのsend-error-as-is-to-clientを指定してください。
}

+ System::Pong {
  # サーバーからのPINGメッセージに対し、自動的にPONGを返す。

  # これをoffにするとクライアントが自らPINGに応答せざるを得なくなりますが、
  # クライアントからのPONGメッセージはデフォルトのサーバーへ送られるので
  # デフォルト以外のサーバーからはPing Timeoutで落とされるなど
  # 全く良い事がありません。
  #   設定項目はありません。
}

+ System::PrivTranslator {
  # クライアントからの個人的なprivが相手に届かなくなる現象を回避する。

  # このモジュールは個人宛てのprivmsgの送信者のnickにネットワーク名を付加します。
  # また、最後に声をかけられてから5分以内の nick 変更をクライアントに伝えます。
  # 設定項目はありませんが、 networks/channel-network-separator を ! や @ 以外に
  # 変更することをおすすめします。
}

+ System::Reload {
  # confファイルやモジュールの更新をリロードするコマンドを追加する。

  # リロードを実行するコマンド名。省略されるとコマンドを追加しません。
  # 例えば"load"を設定すると、"/load"と発言しようとした時にリロードを実行します。
  # この時コマンドはTiarraが握り潰すので、IRCプロトコル上で定義された
  # コマンド名を設定すべきではありません。
  command: load

  # command と同じですが、サーバにもブロードキャストします。
  #broadcast-command: load-all

  # confファイルをリロードしたときに通知します。
  # モジュールの設定が変更されていた場合は、ここでの設定にかかわらず、
  # モジュールごとに表示されます。1または省略された場合は通知します。
  conf-reloaded-notify: 1
}

+ User::Away::Nick {
  # ニックネーム変更に応じて AWAY を設定します。

  # ニックネームを変更したときに、そのニックネームに対応するAWAYが
  # 設定されていれば、そのAWAYを設定します。そうでなければAWAYを取り消します。

  # 書式: <nickのマスク> <設定するAWAYメッセージ>
  #
  # nickをhoge_zzzに変更すると、「寝ている」というAWAYを設定する。
  # hoge_workまたはhoge_zzzに変更した場合は、「仕事中」というAWAYを設定する。
  # それ以外のnickに変更した場合はAWAYを取り消す。
  # 後者は正規表現を利用して「away: re:hoge_(work|zzz) 仕事中」としても良い。
  away: ebith_zzZ          睡眠中
  away: ebith_work         仕事中
  away: ebith_away         お出かけ中
}

+ System::WebClient {
  # ブラウザ上でログを見たり発言したりできます.

  # WebClient を起動させる場所の指定.
  bind-addr: 127.0.0.1
  bind-port: 8668
  path: /irc/
  css:  /style/style.css
  # 上の設定をapacheでReverseProxyさせる場合, httpd.conf には次のように設定.
  #  ProxyPass        /irc/ http://localhost:8667/irc/
  #  ProxyPassReverse /irc/ http://localhost:8667/irc/
  #  <Location /irc/>
  #  ...
  #  </Location>

  # ReverseProxy 利用時の追加設定.
  # 接続元が全部プロキシサーバになっちゃうのでその対応.
  extract-forwarded-for: 127.0.0.1

  # 利用する接続設定の一覧.
  #
  # 空白区切りで評価する順に記述.
  # 使われる設定は,
  # - 接続元 IP が一致する物.
  # - user/passが送られてきていない(認証前/anonymous):
  #   - 認証不要の設定があればその設定を利用.
  #   - 認証不要の設定がなければ 401 Unauthorized.
  # - user/passが送られてきている.
  #   - 一致する設定を利用.
  #   - 一致する設定がなければ 401 Unauthorized.
  allow: private

  # 許可する接続の設定.
  allow-private {
    # 接続元IPアドレスの制限.
    host: *
    # 認証設定.
    auth: ebith 0000
    # 公開するチャンネルの指定.
    mask: #*@*
  }

  # デバッグフラグ.
  #debug: 0

  # 保存する最大行数.
  max-lines: 1000

  # クライアントモード.
  # owner か shared.
  mode: owner

  # 発言BOXで名前指定しなかったときのデフォルトの名前.
  # mode: shared の時に使われる.
  #name-default: somebody
}

- Log::DBI {
 charset: utf8
 command: privmsg,notice

 DBI {
   source: dbi:mysql:tiarra
   user:   tiarrauser
   pass:   fpofhclh
 }
}

+ Client::List {
  # Clientの一覧を取得.

  # 接続しているクライアントを一覧.
  # /clientlist を投げると, その時に接続しているクライアントの一覧を返す.
  # 出力例:
  # clientlist
  #   *** 1 client
  #   *** [1] 127.0.0.1:23695


  # 一覧を返すトリガーとするコマンド.
  #command: clientlist
}